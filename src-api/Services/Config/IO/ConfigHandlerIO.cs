using System.Collections;
using System.Text;
using CounterStrikeSharp.API.Core;
using Tomlyn;
using Tomlyn.Model;
using Kitsune.SDK.Core.Models.Config;
using Kitsune.SDK.Core.Models.Events.Args;
using Kitsune.SDK.Utilities;
using Microsoft.Extensions.Logging;
using Kitsune.SDK.Core.Base;

namespace Kitsune.SDK.Services.Config
{
    /// <summary>
    /// Partial ConfigHandler class containing file I/O operations
    /// </summary>
    public sealed partial class ConfigHandler
    {
        #region File Operations

        /// <summary>
        /// Get the path to a group's config file
        /// </summary>
        private string GetGroupConfigFilePath(string groupName)
            => Path.Combine(_configDirectory, $"{_configOwner}.{groupName}.toml");

        /// <summary>
        /// Updates a config item's value from a TOML value
        /// </summary>
        private void UpdateConfigItemFromToml(ConfigItem item, object tomlValue, string configName)
        {
            object? value = ConvertTomlValueToNetObject(tomlValue);
            if (value == null)
                return;

            // Get the expected type from default value
            Type? expectedType = item.DefaultValue?.GetType();
            if (expectedType == null)
                return;

            try
            {
                // Try to convert to the expected type
                var convertedValue = TypeConverter.ConvertDynamic(value, expectedType);
                if (convertedValue != null && !Equals(convertedValue, item.Value))
                    item.Value = convertedValue;
            }
            catch (Exception)
            {
                // If conversion fails, reset to default
                _logger.LogWarning($"Config '{configName}' value '{value}' incompatible with type '{expectedType.Name}'. Using default.");

                if (item.DefaultValue != null)
                {
                    item.Value = item.DefaultValue;
                }
            }
        }

        /// <summary>
        /// Save a specific group's configuration to file
        /// </summary>
        public async Task SaveGroupConfig(string groupName, SdkPlugin targetPlugin)
        {
            if (!_moduleConfigs.TryGetValue(targetPlugin, out var moduleConfig) || !moduleConfig.Groups.TryGetValue(groupName, out var group))
                return;

            // Use the config directory that was already calculated in the constructor
            // This ensures we use the correct _configOwner (which can be overridden)
            Directory.CreateDirectory(_configDirectory);

            string filePath = GetGroupConfigFilePath(groupName);

            // Handle empty groups - delete the file if it exists
            if (group.Items.IsEmpty)
            {
                if (File.Exists(filePath))
                {
                    try { File.Delete(filePath); }
                    catch { /* Ignore errors */ }
                }
                return;
            }

            // Update timestamp
            moduleConfig.LastUpdated = DateTime.Now;

            // Fire save events if target plugin is this plugin
            var preArgs = new ConfigSaveEventArgs(moduleConfig, _plugin.ModuleName, filePath);
            _plugin.Events.Dispatch(preArgs, HookMode.Pre);

            // Check if this is a new file
            bool isNewFile = !File.Exists(filePath);

            // Generate and write TOML
            await WriteGroupConfigToFileAsync(_configOwner, _configDirectory, groupName, group, moduleConfig);

            // Log file creation
            if (isNewFile)
            {
                var relativePath = $"configs/plugins/{_configOwner}/{_configOwner}.{groupName}.toml";
                _logger.LogInformation($"Created new config file: {relativePath}");
            }

            var postArgs = new ConfigSaveEventArgs(moduleConfig, _plugin.ModuleName, filePath);
            _plugin.Events.Dispatch(postArgs, HookMode.Post);
        }

        /// <summary>
        /// Write a group's configuration to a TOML file
        /// </summary>
        private static async Task WriteGroupConfigToFileAsync(string pluginName, string configDir, string groupName, ConfigGroup group, ModuleConfig moduleConfig)
        {
            // Generate header with metadata
            var header = new StringBuilder();
            header.AppendLine($"# This file was generated by Kitsune.SDK");
            header.AppendLine($"# Module: {moduleConfig.ModuleName}");
            header.AppendLine($"# Group: {groupName}");
            header.AppendLine($"# Created At: {moduleConfig.CreatedAt:yyyy-MM-ddTHH:mm:ssZ}");
            header.AppendLine($"# Last Updated: {moduleConfig.LastUpdated:yyyy-MM-ddTHH:mm:ssZ}");
            header.AppendLine();

            // Build TOML content
            var tomlBuilder = new StringBuilder(header.ToString());

            // Add each config item with description and default value
            foreach (var (configName, item) in group.Items.OrderBy(x => x.Key))
            {
                // Format description with word wrapping for long descriptions
                string description = item.Description;
                if (description.Length > 128)
                {
                    foreach (var line in WrapDescription(description, 128))
                    {
                        tomlBuilder.AppendLine($"# {line}");
                    }
                }
                else
                {
                    tomlBuilder.AppendLine($"# {description}");
                }

                // Add default value comment and the actual value
                tomlBuilder.AppendLine($"# default: {FormatValue(item.DefaultValue)}");

                // Add a note about global, protected or locked configs
                if (item.Flags != ConfigFlag.None)
                {
                    var flagsList = new List<string>();
                    if (item.Flags.HasFlag(ConfigFlag.Global)) flagsList.Add("Global");
                    if (item.Flags.HasFlag(ConfigFlag.Protected)) flagsList.Add("Protected");
                    if (item.Flags.HasFlag(ConfigFlag.Locked)) flagsList.Add("Locked");

                    tomlBuilder.AppendLine($"# flags: {string.Join(", ", flagsList)}");
                }

                tomlBuilder.AppendLine($"{configName} = {FormatValue(item.Value)}");
                tomlBuilder.AppendLine();
            }

            // Write to file
            
            string filePath = Path.Combine(configDir, $"{pluginName}.{groupName}.toml");
            await File.WriteAllTextAsync(filePath, tomlBuilder.ToString());
        }

        // Helper to wrap long descriptions
        private static IEnumerable<string> WrapDescription(string text, int width)
        {
            int currentIndex = 0;

            while (currentIndex < text.Length)
            {
                int remainingLength = text.Length - currentIndex;
                int length = Math.Min(width, remainingLength);

                // If not at the end and the cut doesn't fall on a space, look for a space to break at
                if (length < remainingLength && text[currentIndex + length] != ' ')
                {
                    int lastSpace = text.LastIndexOf(' ', currentIndex + length, length);
                    if (lastSpace > currentIndex)
                    {
                        length = lastSpace - currentIndex;
                    }
                }

                yield return text.Substring(currentIndex, length);
                currentIndex += length;

                // Skip leading space on next line
                if (currentIndex < text.Length && text[currentIndex] == ' ')
                {
                    currentIndex++;
                }
            }
        }

        /// <summary>
        /// Format a value for TOML output
        /// </summary>
        private static string FormatValue(object? value)
        {
            if (value is null)
                return "null";

            return value switch
            {
                string str => $"\"{StringEx.EscapeToml(str)}\"",
                bool b => b.ToString().ToLowerInvariant(),
                DateTime dt => dt.ToString("yyyy-MM-ddTHH:mm:ssZ"),
                IList list => FormatList(list),
                IDictionary dict => FormatDictionary(dict),
                _ => value.ToString() ?? "null"
            };
        }

        // Format a list for TOML output
        private static string FormatList(IList list)
        {
            var items = new List<string>(list.Count);
            foreach (var item in list)
            {
                items.Add(FormatValue(item));
            }

            return $"[{string.Join(", ", items)}]";
        }

        // Format a dictionary for TOML output
        private static string FormatDictionary(IDictionary dict)
        {
            var items = new List<string>(dict.Count);
            foreach (DictionaryEntry entry in dict)
            {
                string key = entry.Key.ToString() ?? string.Empty;
                string val = FormatValue(entry.Value);
                items.Add($"{key} = {val}");
            }

            return items.Count == 0 ? "{ }" : $"{{ {string.Join(", ", items)} }}";
        }

        /// <summary>
        /// Reload all configuration values from files
        /// </summary>
        public async Task ReloadConfigAsync()
        {
            // Get all registered config groups
            var groups = new HashSet<string>();

            if (_moduleConfigs.TryGetValue(_plugin, out var moduleConfig))
            {
                foreach (var group in moduleConfig.Groups.Keys)
                {
                    groups.Add(group);
                }
            }

            // Check for any .toml files that might not be registered yet
            if (Directory.Exists(_configDirectory))
            {
                string pattern = $"{_configOwner}.*.toml";
                foreach (var filePath in Directory.GetFiles(_configDirectory, pattern))
                {
                    // Extract the group name from the file name
                    string fileName = Path.GetFileNameWithoutExtension(filePath);
                    string[] parts = fileName.Split('.');
                    if (parts.Length < 2) continue;

                    string groupName = parts[1]; // Second part is the group name
                    groups.Add(groupName);
                }
            }

            // Load all unique groups
            foreach (string groupName in groups)
            {
                await LoadGroupConfig(groupName);
            }

            // Update all config instances with values from the config files
            foreach (var ((plugin, configType), configInstance) in _configInstances)
            {
                if (plugin == _plugin)
                {
                    UpdateConfigInstanceFromConfig(configInstance, configType);
                }
            }
        }

        /// <summary>
        /// Load a specific configuration group from file
        /// </summary>
        public async Task LoadGroupConfig(string groupName)
        {
            // Fire pre-load event
            if (_moduleConfigs.TryGetValue(_plugin, out var moduleConfig))
            {
                moduleConfig.Groups.GetOrAdd(groupName, new ConfigGroup { Name = groupName });
                var preArgs = new ConfigLoadEventArgs(moduleConfig, _plugin.ModuleName, GetGroupConfigFilePath(groupName));
                _plugin.Events.Dispatch(preArgs, HookMode.Pre);
            }

            string filePath = GetGroupConfigFilePath(groupName);

            // Early return if file doesn't exist
            if (!File.Exists(filePath))
                return;

            try
            {
                // Parse TOML file - only do this once
                string toml = await File.ReadAllTextAsync(filePath);
                TomlTable tomlDocument = Toml.Parse(toml).ToModel();

                // Update registered config items with values from file
                if (_moduleConfigs.TryGetValue(_plugin, out var pluginModuleConfig))
                {
                    var configGroup = pluginModuleConfig.Groups.GetOrAdd(groupName, new ConfigGroup { Name = groupName });
                    var fileNeedsUpdate = false;

                    // Track new and modified configs
                    var newConfigs = new List<string>();

                    // Process all registered configs that exist in the TOML
                    foreach (var configItem in configGroup.Items.Values)
                    {
                        string configName = configItem.Name;

                        // Check if this config exists in the TOML file
                        if (tomlDocument.TryGetValue(configName, out var tomlValue))
                        {
                            // Update the item from TOML
                            try
                            {
                                UpdateConfigItemFromToml(configItem, tomlValue, configName);

                                // Update any config instances with the new value
                                if (configItem.Value != null)
                                {
                                    UpdateConfigInstancesWithNewValue(configName, configItem.Value);
                                }
                            }
                            catch
                            {
                                // Type conversion failed, reset to default
                                _logger.LogWarning($"Config '{configName}' had incompatible value. Resetting to default.");

                                if (configItem.DefaultValue != null)
                                {
                                    configItem.Value = configItem.DefaultValue;
                                    fileNeedsUpdate = true;
                                }
                            }
                        }
                        else
                        {
                            // This is a new config that's not in the file yet
                            newConfigs.Add(configName);
                            fileNeedsUpdate = true;
                        }
                    }

                    // Check for unregistered configs in the TOML file
                    foreach (var tomlKey in tomlDocument.Keys)
                    {
                        if (!configGroup.Items.ContainsKey(tomlKey))
                        {
                            // Found an unregistered config - mark for cleanup
                            fileNeedsUpdate = true;
                            _logger.LogInformation($"Detected unused config '{tomlKey}' in group '{groupName}' - will be removed from file");
                        }
                    }

                    // Log new configs
                    if (newConfigs.Count > 0)
                    {
                        _logger.LogInformation($"Added {newConfigs.Count} new configs to '{groupName}' group");
                    }

                    // Count added and removed configs
                    int removedCount = tomlDocument.Keys.Count(key => !configGroup.Items.ContainsKey(key));

                    // Save changes if the file has unregistered configs
                    if (fileNeedsUpdate)
                    {
                        if (removedCount > 0)
                            _logger.LogInformation($"Removed {removedCount} unused configs from '{groupName}' group");

                        await SaveGroupConfig(groupName, _plugin);
                    }

                    // Check if database configuration values are still example values
                    if (groupName == "database" && (_hasStorageInterface || _hasSettingsInterface))
                    {
                        if (!IsDatabaseValid)
                        {
                            var configPath = $"configs/plugins/{_plugin.ModuleName}/{_plugin.ModuleName}.database.toml";
                            _logger.LogCritical($"Please setup your database configuration in '{configPath}' before using the plugin.");
                        }
                    }

                    // Fire post-load event
                    var postArgs = new ConfigLoadEventArgs(pluginModuleConfig, _plugin.ModuleName, GetGroupConfigFilePath(groupName));
                    _plugin.Events.Dispatch(postArgs, HookMode.Post);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error loading config for group '{groupName}' in module '{_plugin.ModuleName}': {ex.Message}");
            }
        }

        /// <summary>
        /// Convert a TOML value to a .NET object
        /// </summary>
        private static object? ConvertTomlValueToNetObject(object? tomlValue)
        {
            if (tomlValue is null)
                return null;

            return tomlValue switch
            {
                TomlArray array => array.Select(ConvertTomlValueToNetObject).Where(x => x != null).ToList(),
                TomlTable table => table.ToDictionary(kvp => kvp.Key, kvp => ConvertTomlValueToNetObject(kvp.Value)),
                TomlDateTime dateTime => dateTime.DateTime,
                _ => tomlValue
            };
        }

        #endregion
    }
}